// ============================================================
//! # Guardrails - Input Validation Module (Generated by Bastion)
//!
//! このファイルは `bastion init rust` によって自動生成されました。
//! プロンプトインジェクションや XSS などの検知ロジックが含まれています。

use regex::Regex;
use std::sync::OnceLock;

/// 入力バリデーションの結果
#[derive(Debug, PartialEq, Eq)]
pub enum ValidationResult {
    /// 入力は安全
    Valid,
    /// 入力がブロックされた（理由を含む）
    Blocked(String),
}

static INJECTION_PATTERNS: OnceLock<Vec<Regex>> = OnceLock::new();

fn get_patterns() -> &'static Vec<Regex> {
    INJECTION_PATTERNS.get_or_init(|| {
        vec![
            Regex::new(r"(?i)ignore previous instructions").unwrap(),
            Regex::new(r"(?i)system prompt").unwrap(),
            Regex::new(r"(?i)you are an ai").unwrap(),
            Regex::new(r"(?i)<script").unwrap(),
            Regex::new(r"(?i)javascript:").unwrap(),
            Regex::new(r#"(?i)alert\("#).unwrap(),
        ]
    })
}

/// 入力を検証する
pub fn validate_input(input: &str) -> ValidationResult {
    validate_input_with_max_len(input, 4096)
}

/// 最大長を指定して入力を検証する
pub fn validate_input_with_max_len(input: &str, max_len: usize) -> ValidationResult {
    if input.len() > max_len {
        return ValidationResult::Blocked(format!("Input too long (max {} bytes)", max_len));
    }

    let patterns = get_patterns();
    for re in patterns {
        if re.is_match(input) {
            return ValidationResult::Blocked("Potential injection detected".to_string());
        }
    }

    ValidationResult::Valid
}
